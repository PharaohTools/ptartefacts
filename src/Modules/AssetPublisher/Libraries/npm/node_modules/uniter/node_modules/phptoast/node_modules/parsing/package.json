{
  "version": "1.4.0",
  "name": "parsing",
  "description": "JSON grammar-based parser",
  "keywords": [
    "grammar",
    "parse",
    "ast",
    "ll"
  ],
  "homepage": "http://asmblah.github.com/parsing/",
  "author": {
    "name": "Dan Phillimore",
    "email": "dan@ovms.co",
    "url": "http://ovms.co"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/asmblah/parsing"
  },
  "bugs": {
    "url": "http://github.com/asmblah/parsing/issues",
    "email": "dan@ovms.co"
  },
  "main": "index",
  "scripts": {
    "jshint": "jshint .",
    "mocha": "mocha --recursive test/",
    "test": "npm run jshint && npm run mocha"
  },
  "dependencies": {
    "microdash": "^1.0.0"
  },
  "devDependencies": {
    "chai": "^2.3.0",
    "jshint": "^2.8.0",
    "mocha": "^2.2.5",
    "nowdoc": "^1.0.1",
    "sinon": "^1.15.4",
    "sinon-chai": "^2.7.0"
  },
  "engines": {
    "node": ">=0.6"
  },
  "license": "MIT",
  "readme": "Parsing\n=======\n\n[![Build Status](https://secure.travis-ci.org/asmblah/parsing.png?branch=master)](http://travis-ci.org/asmblah/parsing)\n\nA JSON-esque grammar-based parser.\n\nGetting started\n---------------\n```shell\n$ npm install parsing\n$ node\n```\n```javascript\n/**\n * Based on this EBNF grammar\n * - from http://stackoverflow.com/questions/6805172/how-do-you-abstract-some-expression-to-bnf#answer-6805185\n *\n * AEXP => AS+\n * AS   => id ':=' EX1 ';'\n * EX1  => EX2 (('+' | '-') EX2)*\n * EX2  => EX3 (('*' | '/') EX3)*\n * EX3  => EX4 ('^' EX3)*\n * EX4  => ('+'|'-')? EX5\n * EX5  => id | number | '(' EX1 ')'\n */\nvar grammarSpec = {\n    ignore: 'whitespace',\n    rules: {\n        'assign': /:=/,\n        'character': /[;*\\/^+-]/,\n        'id': /[\\w$][\\w\\d$]*/,\n        'number': /\\d(?:\\.\\d+)?/,\n        'whitespace': /\\s+/,\n        'AEXP': {\n            components: {name: 'assignment', oneOrMoreOf: 'AS'}\n        },\n        'AS': {\n            components: [{name: 'target', what: 'id'}, 'assign', {name: 'expression', what: 'EX1'}, {'character': ';'}]\n        },\n        'EX1': {\n            captureAs: 'EX',\n            components: [{name: 'left', what: 'EX2'}, {name: 'right', zeroOrMoreOf: [{name: 'operator', oneOf: [{'character': '+'}, {'character': '-'}]}, {name: 'operand', what: 'EX2'}]}],\n            ifNoMatch: {component: 'right', capture: 'left'}\n        },\n        'EX2': {\n            captureAs: 'EX',\n            components: [{name: 'left', what: 'EX3'}, {name: 'right', zeroOrMoreOf: [{name: 'operator', oneOf: [{'character': '*'}, {'character': '/'}]}, {name: 'operand', what: 'EX3'}]}],\n            ifNoMatch: {component: 'right', capture: 'left'}\n        },\n        'EX3': {\n            captureAs: 'EX',\n            components: [{name: 'left', what: 'EX4'}, {name: 'right', zeroOrMoreOf: [{name: 'operator', what: {'character': '^'}}, {name: 'operand', rule: 'EX3'}]}],\n            ifNoMatch: {component: 'right', capture: 'left'}\n        },\n        'EX4': {\n            captureAs: 'EX',\n            components: [{name: 'operator', optionally: {oneOf: [{'character': '+'}, {'character': '-'}]}}, {name: 'operand', what: 'EX5'}],\n            ifNoMatch: {component: 'operator', capture: 'operand'}\n        },\n        'EX5': {\n            components: [{oneOf: ['id', 'number', [{'character': '('}, 'EX1', {'character': ')'}]]}]\n        }\n    },\n    start: 'AEXP'\n};\n\nvar parser = require('parsing').create(grammarSpec);\n\nconsole.log(parser.parse('waldo:=1;'));\n/**\n * Gives:\n * {\n *     name: 'AEXP',\n *     assignment: [{\n *         name: 'AS',\n *         target: 'waldo',\n *         expression: '1'\n *     }]\n * }\n */\n```\n\nExtending a grammar / Defining custom rules\n-------------------------------------------\nSometimes it can be handy to extend an existing grammar by defining custom rules and overriding some existing ones.\nFor example, given this simple grammar we could add a new statement type to it:\n\n```javascript\nvar grammarSpec = {\n    ignore: 'whitespace',\n    rules: {\n        'go_statement': {\n            components: [{what: /go/, allowMerge: false}]\n        },\n        'end_statement': {\n            components: [{what: /end/, allowMerge: false}]\n        },\n        'whitespace': /\\s+/,\n        'single_statement': {\n            components: {oneOf: ['go_statement', 'end_statement']}\n        },\n        'statement': {\n            components: ['single_statement', /;/]\n        },\n        'program': {\n            components: {name: 'statements', zeroOrMoreOf: 'statement'}\n        }\n    },\n    start: 'program'\n};\n\n// Note the third `options` argument here, which we use to pass the custom rule specs,\n// adding support for the new `do_something_custom;` statement to the above grammar\nvar parser = require('parsing').create(grammarSpec, null, {\n    rules: {\n        'do_something_statement': {\n            components: [{what: /do_something_custom/, allowMerge: false}]\n        },\n        'single_statement': {\n            // Override `single_statement`, but refer back to the original\n            components: {oneOf: ['do_something_statement', 'single_statement']}\n        }\n    }\n});\n\nconsole.log(parser.parse('go; do_something_custom; end;'));\n/**\n * Gives:\n * {\n *     name: 'program',\n *     statements: [\n *         { name: 'go_statement' },\n *         { name: 'do_something_statement' },\n *         { name: 'end_statement' }\n *     ]\n * }\n */\n```\n\nKeeping up to date\n------------------\n- [Follow me on Twitter](https://twitter.com/@asmblah) for updates: [https://twitter.com/@asmblah](https://twitter.com/@asmblah)\n",
  "readmeFilename": "README.md",
  "_id": "parsing@1.4.0",
  "dist": {
    "shasum": "3d5c93240514be13b9be0fa8e024bee640c73622"
  },
  "_from": "parsing@^1.1.0",
  "_resolved": "https://registry.npmjs.org/parsing/-/parsing-1.4.0.tgz"
}
